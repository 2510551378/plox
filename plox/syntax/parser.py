from typing import List
from plox.error import error, PLoxRuntimeError, runtime_error
from plox.lexer.token import *
from plox.syntax.expr import *
from plox.syntax import stmt



class Parser:
    def __init__(self, tokens: List[Token]):
        """
        There two kinds of things to parse, statement (plox.syntax.stmt) or expression (plox.syntax.expr).
        For statement, the return type is Stmt, whereas for expression, the return type is Expr.
        They are both used by interpreter to execute for expected results.

        Args:
            tokens: lexical tokens generated by the lexical scanner.
        
        Attributes:
            current: pointer point to the next token waiting to be parsed.
        """
        self.tokens = tokens
        self.current = 0

    def parse(self):
        statements = []
        while not self.is_end():
            statements.append(self.declaration())
        
        return statements

    def peek(self):
        return self.tokens[self.current]

    def is_end(self):
        return isinstance(self.peek(), EOF)
    
    def previous(self):
        return self.tokens[self.current-1]

    def advance(self):
        if not self.is_end(): self.current += 1
        return self.previous()

    def check(self, token_type: Token):
        """
        Check whether the current token is an instance of token_type.
        Return false if currently is at the end. 
        """
        if self.is_end(): return False
        return isinstance(self.peek(), token_type)

    def match(self, *token_types):
        for token_type in token_types:
            if self.check(token_type):
                self.advance()
                return True
        return False

    def consume(self, token_type: Token, message: str):
        if self.check(token_type):
            return self.advance()

        error(self.peek().line, message)
        exit(1)

    def declaration(self):
        try:
            if self.match(VAR):
                return self.var_declaration()
            
            return self.statement()
        except:
            pass
        
    def var_declaration(self):
        """
        Syntax:
            varDecl := "var" IDENTIFIER ( "=" expression)? ";" ;
        """
        name = self.consume(IDENTIFIER, "Expect variable name.")
        initializer = None

        if self.match(EQUAL):
            initializer = self.expression()
        
        self.consume(SEMICOLON, "Expect ';' after variable declaration.")
        return stmt.Var(name, initializer)

    """
        9.2 add after statement()
    """

    def if_statement(self):
        self.consume(LEFT_PAREN,"Expect '(' after 'if'.")
        condition = self.expression()
        self.consume(RIGHT_PAREN,"Expect ')' after if condition.")
        thenBranch = self.statement()
        elseBranch = None
        if self.match(ELSE):
            elseBranch = self.statement()
        
        return stmt.If(condition, thenBranch, elseBranch)


    def statement(self) :
        if self.match(FOR):
            return self.for_statement()
        if self.match(IF):
            return self.if_statement()
        if self.match(PRINT):
            return self.print_statement()
        if self.match(WHILE):
            return self.while_statement()
        if self.match(LEFT_BRACE):
            return stmt.Block(self.block())
        return self.expression_statement()
        
    def while_statement(self):
        self.consume(LEFT_PAREN, "Expect '(' after 'while'.")
        condition = self.expression()
        self.consume(RIGHT_PAREN, "Expect ')' after condition.")
        body = self.statement()
        return stmt.While(condition, body)
    
    def for_statement(self):
        self.consume(LEFT_PAREN, "Expect '(' after 'for'.")
        #More here......
        initializer = None
        if self.match(SEMICOLON):
            initializer = None
        elif self.match(VAR):
            initializer = self.var_declaration()
        else:
            initializer = self.expression_statement()
        condition = None
        if not self.check(SEMICOLON):
            condition = self.expression()

        self.consume(SEMICOLON,"Expect ';' after loop condition.")

        increment = None
        if not self.check(RIGHT_PAREN):
            increment = self.expression()
        self.consume(RIGHT_PAREN,"Expect ')' after for clauses.")

        body = self.statement()
        if increment is not None:
            lists = []
            lists.append(initializer)
            lists.append(body)
            body = stmt.Block(lists)

        if condition is None:
            condition = Literal(True)

        body = stmt.While(condition, body)
        
        return body

    def print_statement(self):
        """
        printStmt := "print" expression ";" ;
        """
        value = self.expression()
        self.consume(SEMICOLON, "Expect ; after expression.")
        return stmt.Print(value)

    def expression_statement(self):
        expr = self.expression()
        self.consume(SEMICOLON, "Expect ; after expression.")
        return stmt.Expression(expr)

    def expression(self):
        """
        Syntax:
            expression := assignment ;
        """
        return self.assignment()

    def assignment(self):
        """
        Syntax:
            assignment := (call ".")? IDENTIFIER "=" assigment 
                          | logic_or ;
        """
        # NOTE: `(call ".")? IDENTIFIER` can be derived with logic_or syntax
        expr = self.logic_or()

        if self.match(EQUAL):
            # NOTE: `equals` is the token EQUAL and `value` is an Expr derived by assignment()
            equals = self.previous()
            value = self.assignment()

            if isinstance(expr, Variable):
                name = expr.name
                return Assign(name, value)
            elif isinstance(expr, Get):
                get = expr
                return Set(get.object, get.name, value)
            else:
                error(equals.line, "Invalid Assignment Target.")
        
        return expr
        

    def logic_or(self):
        """
        Syntax:
            logic_or := logic_and ( "or" logic_and )* ;
        """
        expr = self.logic_and()

        while self.match(OR):
            operator = self.previous()
            right = self.logic_and()
            expr = Logical(expr, operator, right)

        return expr

    def logic_and(self):
        """
        Syntax:
           logic_and := equality ( "and" equality )* ;
        """
        expr = self.equality()

        while self.match(AND):
            operator = self.previous()
            right = self.equality()
            expr = Logical(expr, operator, right)

        return expr

    def equality(self):
        """
        Syntax:
            equality := comparison ( ( "!=" | "==" ) comparison )* ;
        """
        expr = self.comparison()

        while self.match(BANG_EQUAL, EQUAL_EQUAL):
            operator = self.previous()
            right = self.comparison()
            expr = Binary(expr, operator, right)

        return expr

    def comparison(self):
        """
        Syntax:
            comparison := term ( ( ">" | ">=" | "<" | "<=" ) term )* ;
        """
        expr = self.term()

        while self.match(GREATER, GREATER_EQUAL, LESS, LESS_EQUAL):
            operator = self.previous()
            right = self.term()
            expr = Binary(expr, operator, right)

        return expr

    def term(self):
        """
        Syntax:
            term := factor ( ( "-" | "+" ) factor )* ;
        """
        expr = self.factor()

        while self.match(MINUS, PLUS):
            operator = self.previous()
            right = self.factor()
            expr = Binary(expr, operator, right)
        
        return expr

    def factor(self):
        """
        Syntax:
            factor := unary ( ( "/" | "*" ) unary )* ;
        """
        expr = self.unary()

        while self.match(SLASH, STAR):
            operator = self.previous()
            right = self.unary()
            expr = Binary(expr, operator, right)

        return expr

    def unary(self):
        """
        Syntax:
            unary := ( "!" | "-" ) unary 
                     | call ;
        """
        if self.match(BANG, MINUS):
            operator = self.previous()
            right = self.unary()
            return Unary(operator, right)
        
        return self.call()

    def call(self):
        """
        Syntax:
            call := primary ( "(" arguments? ")" | "." IDENTIFIER )* ;
        """
        expr = self.primary()

        while True:
            if self.match(LEFT_PAREN):
                expr = self.finishCall(expr)
            elif self.match(DOT):
                name = self.consume(IDENTIFIER, "Expect property name after '.'.")
                expr = Get(expr, name)
            else:
                break
        
        return expr

    def finishCall(self, callee: Expr):
        arguments = []
        if not self.check(RIGHT_PAREN):
            while True:
                if len(arguments) >= 255:
                    error(self.peek().line, "Can't have more than 255 arguments.")
                
                arguments.append(self.expression())
                
                if self.match(COMMA):
                    continue
                else:
                    break
        
        paren = self.consume(RIGHT_PAREN, "Expect ')' after arguments.")
        return Call(callee, paren, arguments)

    def primary(self):
        """
        Syntax:
            primary := "true" | "false" | "nil" | "this"
                       | NUMBER | STRING | IDENTIFIER | "(" expression ")"
                       | "super" "." IDENTIFIER ;
        """
        if self.match(FALSE): return Literal(False)
        if self.match(TRUE): return Literal(True)
        if self.match(NIL): return Literal(None)

        if self.match(NUMBER, STRING): return Literal(self.previous().literal)

        if self.match(SUPER):
            keyword = self.previous()
            self.consume(DOT, "Expect '.' after 'super'.")
            method = self.consume(IDENTIFIER, "Expect superclass method name.")
            return Super(keyword, method)
        
        if self.match(THIS):
            return This(self.previous())

        if self.match(IDENTIFIER):
            return Variable(self.previous())

        if self.match(LEFT_PAREN):
            expr = self.expression()
            self.consume(RIGHT_PAREN, "Expect ')' after expression.")
            return Grouping(expr)
        
        error(self.peek().line, "Expect expression.")        
    